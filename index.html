<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Grid Game with Monsters</title>
<style>
  body {
    font-family: monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 20px;
    user-select: none;
  }
  #playerHealth {
    margin-bottom: 10px;
    font-weight: bold;
    font-size: 18px;
  }
  #game {
    position: relative;
    display: grid;
    grid-template-columns: repeat(10, 50px);
    grid-template-rows: repeat(10, 50px);
    gap: 2px;
    margin-bottom: 15px;
  }
  .cell {
    width: 50px;
    height: 50px;
    font-size: 32px;
    text-align: center;
    line-height: 50px;
    cursor: pointer;
    border-radius: 6px;
    user-select: none;
    position: relative;
  }
  .grass {
    background-color: #4caf50; /* green */
  }
  .block-brown {
    background-color: #8b4513; /* brown */
  }
  .door-closed {
    background-color: #d2b48c; /* tan */
    color: black;
  }
  .door-open {
    background-color: #ffe4b5; /* lighter tan */
    color: black;
  }
  #controls {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 20px;
  }
  button {
    font-size: 24px;
    width: 60px;
    height: 60px;
    border-radius: 10px;
    border: none;
    background: #333;
    color: white;
    user-select: none;
  }
  button:active {
    background: #666;
  }
  #inventory {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
  }
  .inventory-item {
    font-size: 36px;
    width: 56px;
    height: 56px;
    text-align: center;
    line-height: 56px;
    border-radius: 8px;
    cursor: pointer;
    border: 3px solid transparent;
    user-select: none;
  }
  .selected {
    border-color: #00ff00;
  }
  /* Monster health bar */
  .monster-health {
    position: absolute;
    top: 2px;
    left: 50%;
    transform: translateX(-50%);
    width: 40px;
    height: 6px;
    background: red;
    border-radius: 3px;
    border: 1px solid #000;
  }
  .monster-health-inner {
    height: 100%;
    background: limegreen;
    border-radius: 2px;
  }
</style>
</head>
<body>

<h2>Grid Game with Monsters üëø</h2>
<div id="playerHealth">Player HP: 10/10</div>

<div id="game"></div>

<div id="controls">
  <button id="up">‚¨ÜÔ∏è</button>
  <button id="left">‚¨ÖÔ∏è</button>
  <button id="down">‚¨áÔ∏è</button>
  <button id="right">‚û°Ô∏è</button>
</div>

<div id="inventory"></div>

<script>
  const ROWS = 10;
  const COLS = 10;

  const CELL_GRASS = "grass";

  // Blocks allowed to place
  const BLOCK_TYPES = {
    brown: { emoji: "üü´", class: "block-brown", walkable: false },
    door: { emoji: "üö™", classClosed: "door-closed", classOpen: "door-open", walkable: false }
  };

  const PLAYER_EMOJI = "üòÄ";

  // Player stats
  let playerHP = 10;
  const playerMaxHP = 10;
  const playerDamage = 2;

  // Monster stats
  const monsterMaxHP = 10;
  const monsterDamage = 1;

  // Grid holds strings or objects (for doors)
  let grid = [];
  for (let r = 0; r < ROWS; r++) {
    let row = [];
    for (let c = 0; c < COLS; c++) {
      row.push(CELL_GRASS);
    }
    grid.push(row);
  }

  // Player position
  let playerPos = { r: 0, c: 0 };

  // Selected inventory key: only brown, door, and delete allowed
  let selectedBlockKey = "brown";

  // Monsters array: each monster = {r, c, hp}
  let monsters = [];

  const gameDiv = document.getElementById("game");
  const inventoryDiv = document.getElementById("inventory");
  const playerHealthDiv = document.getElementById("playerHealth");

  // Check adjacency (up/down/left/right)
  function isAdjacent(pos1, pos2) {
    const dr = Math.abs(pos1.r - pos2.r);
    const dc = Math.abs(pos1.c - pos2.c);
    return (dr + dc === 1);
  }

  // Can player walk into cell?
  function canWalk(r, c) {
    if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return false;

    const cell = grid[r][c];
    if (cell === CELL_GRASS) return true;

    if (typeof cell === "string") {
      if (BLOCK_TYPES[cell]) return false;
      return true;
    }

    if (typeof cell === "object" && cell.type === "door") {
      return cell.open;
    }

    return false;
  }

  // Check if monster is at position
  function monsterAt(r, c) {
    return monsters.find(m => m.r === r && m.c === c);
  }

  // Move player
  function movePlayer(dr, dc) {
    const newR = playerPos.r + dr;
    const newC = playerPos.c + dc;

    if (canWalk(newR, newC) && !monsterAt(newR, newC)) {
      playerPos = { r: newR, c: newC };
      render();
    }
  }

  // Player attack monsters if adjacent
  function playerAttack() {
    for (const m of monsters) {
      if (isAdjacent(playerPos, m)) {
        m.hp -= playerDamage;
        if (m.hp <= 0) {
          monsters = monsters.filter(x => x !== m);
        }
        render();
        return;
      }
    }
  }

  // Place block if adjacent, allowed block, and cell is grass
  function placeBlock(r, c) {
    if (!(Math.abs(playerPos.r - r) + Math.abs(playerPos.c - c) === 1)) return;
    if (grid[r][c] !== CELL_GRASS) return;
    if (selectedBlockKey !== "brown" && selectedBlockKey !== "door") return;

    if (selectedBlockKey === "door") {
      grid[r][c] = { type: "door", open: false };
    } else {
      grid[r][c] = selectedBlockKey;
    }
    render();
  }

  // Delete block if adjacent and not player pos
  function deleteBlock(r, c) {
    if (!(Math.abs(playerPos.r - r) + Math.abs(playerPos.c - c) === 1)) return;
    if (playerPos.r === r && playerPos.c === c) return;

    if (grid[r][c] !== CELL_GRASS) {
      grid[r][c] = CELL_GRASS;
      render();
    }
  }

  // Move monsters toward player, attack if adjacent
  function moveMonsters() {
    for (const m of monsters) {
      // Attack if adjacent to player
      if (isAdjacent(m, playerPos)) {
        playerHP -= monsterDamage;
        if (playerHP <= 0) {
          alert("You died! Game over.");
          resetGame();
          return;
        }
        continue;
      }

      // Find best move closer to player
      let bestMove = null;
      let bestDist = 1000;
      const moves = [
        { dr: -1, dc: 0 },
        { dr: 1, dc: 0 },
        { dr: 0, dc: -1 },
        { dr: 0, dc: 1 }
      ];

      for (const move of moves) {
        const nr = m.r + move.dr;
        const nc = m.c + move.dc;
        if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue;

        const cell = grid[nr][nc];

        if (cell === CELL_GRASS && !monsterAt(nr, nc) && !(nr === playerPos.r && nc === playerPos.c)) {
          const dist = Math.abs(nr - playerPos.r) + Math.abs(nc - playerPos.c);
          if (dist < bestDist) {
            bestDist = dist;
            bestMove = { r: nr, c: nc };
          }
        } else if (typeof cell === "object" && cell.type === "door" && cell.open) {
          if (!monsterAt(nr, nc) && !(nr === playerPos.r && nc === playerPos.c)) {
            const dist = Math.abs(nr - playerPos.r) + Math.abs(nc - playerPos.c);
            if (dist < bestDist) {
              bestDist = dist;
              bestMove = { r: nr, c: nc };
            }
          }
        }
      }

      if (bestMove) {
        m.r = bestMove.r;
        m.c = bestMove.c;
      }
    }
    render();
  }

  // Spawn monster offscreen then move inside grid
  function spawnMonster() {
    let spawnOptions = [];

    for(let c=0; c<COLS; c++) spawnOptions.push({r:-1, c:c});
    for(let c=0; c<COLS; c++) spawnOptions.push({r:ROWS, c:c});
    for(let r=0; r<ROWS; r++) spawnOptions.push({r:r, c:-1});
    for(let r=0; r<ROWS; r++) spawnOptions.push({r:r, c:COLS});

    let spawnPos = spawnOptions[Math.floor(Math.random() * spawnOptions.length)];

    let newR = spawnPos.r;
    let newC = spawnPos.c;

    if (spawnPos.r < 0) newR = 0;
    else if (spawnPos.r >= ROWS) newR = ROWS - 1;

    if (spawnPos.c < 0) newC = 0;
    else if (spawnPos.c >= COLS) newC = COLS - 1;

    if (grid[newR][newC] === CELL_GRASS && !monsterAt(newR,newC) && !(newR === playerPos.r && newC === playerPos.c)) {
      monsters.push({ r: newR, c: newC, hp: monsterMaxHP });
    }
  }

  // Reset game
  function resetGame() {
    grid = [];
    for (let r = 0; r < ROWS; r++) {
      let row = [];
      for (let c = 0; c < COLS; c++) {
        row.push(CELL_GRASS);
      }
      grid.push(row);
    }
    playerPos = { r: 0, c: 0 };
    playerHP = playerMaxHP;
    monsters = [];
    selectedBlockKey = "brown";
    renderInventory();
    render();
  }

  // Render everything
  function render() {
    gameDiv.innerHTML = "";
    playerHealthDiv.textContent = `Player HP: ${playerHP}/${playerMaxHP}`;

    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const cellDiv = document.createElement("div");
        cellDiv.classList.add("cell");

        const cellData = grid[r][c];

        if (playerPos.r === r && playerPos.c === c) {
          cellDiv.textContent = PLAYER_EMOJI;
          cellDiv.classList.add("grass");
        } else if (typeof cellData === "string") {
          if (cellData === CELL_GRASS) {
            cellDiv.classList.add("grass");
            cellDiv.textContent = "";
          } else if (BLOCK_TYPES[cellData]) {
            cellDiv.classList.add(BLOCK_TYPES[cellData].class);
            cellDiv.textContent = BLOCK_TYPES[cellData].emoji;
          } else {
            cellDiv.classList.add("grass");
          }
        } else if (typeof cellData === "object" && cellData.type === "door") {
          if (cellData.open) {
            cellDiv.classList.add(BLOCK_TYPES.door.classOpen);
            cellDiv.textContent = BLOCK_TYPES.door.emoji + "O";
          } else {
            cellDiv.classList.add(BLOCK_TYPES.door.classClosed);
            cellDiv.textContent = BLOCK_TYPES.door.emoji + "C";
          }
        } else {
          cellDiv.classList.add("grass");
          cellDiv.textContent = "";
        }

        cellDiv.dataset.r = r;
        cellDiv.dataset.c = c;

        // Show monster if any
        const monster = monsterAt(r, c);
        if (monster) {
          const monsterSpan = document.createElement("span");
          monsterSpan.textContent = "üëø";
          monsterSpan.style.position = "absolute";
          monsterSpan.style.top = "4px";
          monsterSpan.style.left = "50%";
          monsterSpan.style.transform = "translateX(-50%)";
          monsterSpan.style.fontSize = "32px";
          monsterSpan.style.pointerEvents = "none";
          cellDiv.appendChild(monsterSpan);

          const healthBar = document.createElement("div");
          healthBar.classList.add("monster-health");
          const healthInner = document.createElement("div");
          healthInner.classList.add("monster-health-inner");
          healthInner.style.width = (monster.hp / monsterMaxHP * 100) + "%";
          healthBar.appendChild(healthInner);
          cellDiv.appendChild(healthBar);
        }

        // Click handler
        cellDiv.onclick = () => {
          // Toggle door open/close
          if (typeof grid[r][c] === "object" && grid[r][c].type === "door") {
            grid[r][c].open = !grid[r][c].open;
            render();
            return;
          }

          // Attack monster if clicked and adjacent
          const monsterHere = monsterAt(r, c);
          if (monsterHere && isAdjacent(playerPos, {r, c})) {
            monsterHere.hp -= playerDamage;
            if (monsterHere.hp <= 0) {
              monsters = monsters.filter(m => m !== monsterHere);
            }
            render();
            return;
          }

          // Place or delete blocks
          if (selectedBlockKey === "delete") {
            deleteBlock(r, c);
          } else {
            placeBlock(r, c);
          }
        };

        gameDiv.appendChild(cellDiv);
      }
    }
  }

  // Render inventory with brown, door, and delete
  function renderInventory() {
    inventoryDiv.innerHTML = "";
    const items = [
      { key: "brown", emoji: BLOCK_TYPES.brown.emoji },
      { key: "door", emoji: BLOCK_TYPES.door.emoji },
      { key: "delete", emoji: "üóëÔ∏è" }
    ];

    items.forEach(({key, emoji}) => {
      const itemDiv = document.createElement("div");
      itemDiv.classList.add("inventory-item");
      if (key === selectedBlockKey) itemDiv.classList.add("selected");
      itemDiv.textContent = emoji;
      itemDiv.onclick = () => {
        selectedBlockKey = key;
        renderInventory();
      };
      inventoryDiv.appendChild(itemDiv);
    });
  }

  // Handle arrow keys for player movement
  window.addEventListener("keydown", (e) => {
    switch(e.key) {
      case "ArrowUp": movePlayer(-1, 0); break;
      case "ArrowDown": movePlayer(1, 0); break;
      case "ArrowLeft": movePlayer(0, -1); break;
      case "ArrowRight": movePlayer(0, 1); break;
    }
  });

  // Button controls
  document.getElementById("up").onclick = () => movePlayer(-1,0);
  document.getElementById("down").onclick = () => movePlayer(1,0);
  document.getElementById("left").onclick = () => movePlayer(0,-1);
  document.getElementById("right").onclick = () => movePlayer(0,1);

  // Spawn monsters every 5 seconds
  setInterval(() => {
    spawnMonster();
  }, 5000);

  // Monsters move every 1 second
  setInterval(() => {
    moveMonsters();
  }, 1000);

  renderInventory();
  render();
</script>

</body>
</html>
